# c/c++ 练习代码

> create by afterloe<afterloe@foxmail.com>  
> MIT License  
> version 1.4

## 随手笔记
### extern 关键字
extern
用于申明变量，如[代码3](./3-learn.c)的内容。也可以用于在一个源文件引用另一个源文件中的内容如代码4-1，4-2的内容。

### gcc编译两个文件
```bash
# gcc 4-1-learn.c 4-2-learn.c -o ./out/4.out
# ./out/4.out
```
> 文件顺序与编译顺序无关，试过将两个文件的顺序颠倒，不影响正常内容输出。

### signed
signed意思为有符号的，也就是第一个位代表正负，剩余的代表大小  
unsigned意思为无符号的，所有的位都为大小，没有负数  
默认为*signed*

### static
Clang不支持在调用函数时返回局部变量的地址，因为局部变量的地址存储在内存的栈区域，当函数调用结束时，函数与其对应的局部变量生命周期结束，函数内的变量不再拥有那个内存地址，所以不能返回其指针。使用static关键字将该存储变为静态数据即可。

### size\_t 、lu
size\_t 类型定义在cstddef头文件中，是一个与机器相关的unsigned类型，其大小足以保证存储内存中对象的大小。  
lu 为 32位无符号整数，用于`printf("%lu");`中使用。

### 文件模式描述

 模式 | 描述
-|-
 r | 打开一个已有文本文件，并进行读取
 w | 打开一个文本文件，并进行写入；若文件不存在，则创建；默认从头写入，即文件存在，后续内容会丢失
 a | 打开一个文本文件，并进行写入；若文件不存在，则创建；默认文件末尾写入，即追加
 r+ | 打开一个文件，并进行读写
 w+ | 打开一个文件，并进行读写; 若文件不存在，则创建；默认从头写入，即文件存在，后续内容会丢失
 a+ | 打开一个文件，并进行读写；若文件不存在，则创建；默认文件末尾写入，即追加

即`rb wb ab rb+ r+b wb+ w+b ab+ a+b`

### 拷贝构造函数
拷贝构造函数是一种特殊的构造函数，是使用同一类中之前创建的对象来初始化新创建的对象。通常用于以下几种场景:
- 通过使用另一个同类型的对象来初始化新创建的对象；
- 复制对象把它作为参数传递给函数；
- 复制对象，并从函数返回这个对象。
如果一个类带有指针变量，并有动态内存分配，必须写一个拷贝构造函数。在析构函数中必须释放这个指针。

### 友元函数/类
该项内容是定义在类外部，具有访问类的所有private、protected的成员，是用关键字`friend`，该函数也是会调拷贝函数的。

### 指针拷贝
注意千万不要用地址拷贝的方式进行指针拷贝，在free的过程中会出现invalid pointer的问题。

### 内联函数
使用关键`inline` 进行，引入内联函数的目的是为了解决程序中函数调用的效率问题。内联函数一般都是1-5行的小函数。并且注意以下事项
- 不允许使用循环语句和开关语句
- 内联函数的定义必须出现在内联函数第一次调用之前
- 类结构中所在的类说明内部定义的函数是内联函数
滥用内联将导致程序变慢. 内联可能使目标代码量或增或减, 这取决于内联函数的大小. 内联非常短小的存取函数通常会减少代码大小, 但内联一个相当大的函数将增加代码大小.
现代处理器由于更好的利用了指令缓存, 小巧的代码往往执行更快.

### 虚函数
虚函数可以为private, 并且可以被子类覆盖（因为虚函数表的传递），但子类不能调用父类的private虚函数。虚函数的重载性和它声明的权限无关
纯虚函数可以设计成私有的，不过这样不允许在本类之外的非友元函数中直接调用它，子类中只有覆盖这种纯虚函数的义务，却没有调用它的权利

### 宏
\#define 定义，不用配置类型，不用以分号结尾。 可以直接使用，另宏亦可定义一个带有参数的宏如`#define MIN(a,b) (a<b? a:b)`

### 线程
如果设置为 PTHREAD_CREATE_JOINABLE，则使用 pthread_join() 来等待和释放资源，否则会内存泄露。

## Boost
boost 是一个c++不错的轮子，使用方法如下
- download [boost](https://www.boost.org/)
> 我下载的是boost_1_71_0.tar.gz, 以下命令可能跟以往的不一样
```sbtshell
$ tar -xzvf boost_1_71_0.tar.gz && cd boost_1_71_0
$ ./bootstrap.sh --prefix=path/to/installation/prefix // prefix的值是你希望安装boost的路径, 不开启此参数的话默认安装在 /usr/local 下
$ ./b2 install
```
> \~会被当成一个'\~'目录， 因为编译脚本不识别
使用g++对文件进行编译 `g++ -o ./main.out -w -Wall -std=c++17 1-learn.cpp -I ../../lib/include/` 其中include就是boost经过b2 install后的目录
```sbtshell
$ g++ test.cpp -o test -I /home/xzz/boost_1_56_0/include -L -static /home/xzz/boost_1_56_0/lib -lboost_system -lboost_filesystem
```
